function [xtraj, xtrajdes, ttraj, terminate_cond] = hybrid_test_trajectory(start, loadstart, loadstop, vis, trajhandle,pl_params,quad_params)
% TEST_TRAJECTORY simulates the robot from START to STOP following a PATH
% that's been planned for MAP.
% start - a 3d vector or a cell contains multiple 3d vectors
% stop  - a 3d vector or a cell contains multiple 3d vectors
% map   - map generated by your load_map
% path  - n x 3 matrix path planned by your dijkstra algorithm
% vis   - true for displaying visualization

% Get nquad
nquad = length(start);

%% ************************ ROS Initialization **************************
worldframe = 'simulator';
payloadframe = 'payload';

cable_pub = rospublisher("/cable/marker","visualization_msgs/Marker","DataFormat","struct");
cable_marker_scale = 0.01*ones(3);
cable_marker_color = [1.0,0.5,0.5,0.5];
cable_marker_msg = init_marker_msg(cable_pub,5,0,worldframe,cable_marker_scale,cable_marker_color);

for i = 1:nquad
    robot_marker_pub{i} = rospublisher("/quadrotor"+num2str(i)+"/marker","visualization_msgs/Marker","DataFormat","struct");
    quadrotor_marker_scale = 0.5*ones(3);
    quadrotor_marker_color = [1.0,0.0,0.0,1.0];
    quadrotor_mesh = quad_params.mesh_path; %TODO: move this to quadrotor params.
    quadrotor_marker_msg{i} = init_marker_msg(robot_marker_pub{i} ,10,0,worldframe,quadrotor_marker_scale,quadrotor_marker_color,quadrotor_mesh);
end

pl_odom_pub = rospublisher("/payload/marker","visualization_msgs/Marker","DataFormat","struct");
payload_marker_scale = ones(3);
payload_marker_color = [1.0,0.745,0.812,0.941];

system_pub = rospublisher("/system/marker","visualization_msgs/MarkerArray","DataFormat","struct");
system_marker = rosmessage(system_pub);

path_pub = rospublisher("/payload/path","visualization_msgs/Marker","DataFormat","struct");
path_scale = 0.01*ones(3);
path_color = [1.0,1.0,0.0,0.0];
path_msg = init_marker_msg(path_pub,4,0,worldframe,path_scale,path_color);

des_path_pub = rospublisher("/payload/des_path","visualization_msgs/Marker","DataFormat","struct");
des_path_scale = 0.01*ones(3);
des_path_color = [1.0,0.341,0.0235,0.549];
des_path_msg = init_marker_msg(des_path_pub,4,0,worldframe,des_path_scale,des_path_color);

%Controller and trajectory generator handles

if nquad == 1
    controlhandle = @single_payload_geometric_controller;
    payload_marker_scale = ones(3)*0.1;
    dynamicshandle = @(t,s,pl_params) hybrid_ptmass_pl_transportationEOM(t, s, controlhandle, trajhandle, quad_params, pl_params);
    payload_marker_msg = init_marker_msg(pl_odom_pub,2,0,worldframe,payload_marker_scale,payload_marker_color);
else
    quadattcontrolhandle = @cooperative_attitude_controller;
    plcontrolhandle = @cooperative_payload_controller;
    dynamicshandle = @(t,s) cooperative_suspended_pl_transportationEOM(t, s, nquad, plcontrolhandle, quadattcontrolhandle, trajhandle, quad_params, pl_params);
    payload_mesh = 'package://mesh_visualization/mesh/triangular_payload.STL'; %TODO move this to pl_params
    payload_marker_msg = init_marker_msg(pl_odom_pub,10,0,worldframe,payload_marker_scale,payload_marker_color,payload_mesh);
end

% Make cell
if ~iscell(start), start = {start}; end

% Make column vector
for qn = 1:nquad
    start{qn} = start{qn}(:);
end

%% **************************** FIGURES *****************************
% Environment figure
if nargin < 5
    vis = true;
end

fprintf('Initializing figures...\n')
if vis
    h_fig = figure('Name', 'Environment');
else
    h_fig = figure('Name', 'Environment', 'Visible', 'Off');
end

h_3d = gca;
drawnow;
xlabel('x [m]'); ylabel('y [m]'); zlabel('z [m]')
quadcolors = lines(nquad);
set(gcf,'Renderer','OpenGL')

%% *********************** INITIAL CONDITIONS ***********************
fprintf('Setting initial conditions...\n')
% Maximum time that the quadrotor is allowed to fly
time_tol = 60;          % maximum simulation time
starttime = 0;          % start of simulation in seconds
tstep     = 0.01;       % this determines the time step at which the solution is given
cstep     = 0.05;       % image capture time interval
nstep     = cstep/tstep;
time      = starttime;  % current time
max_iter  = time_tol / cstep;      % max iteration

for qn = 1:nquad
    x0{qn}    = init_state(start{qn}, 0);
end

x = [loadstart(1:3);0;0;0;start{1};0;0;0;x0{qn}(7:end)]; %Temporary setting for point mass simulation
xtraj{1} = [];
ttraj{1} = [];
xtrajdes{1} = [];

% Maximum position error of the quadrotor at goal
pos_tol  = 0.05; % m
% Maximum speed of the quadrotor at goal
vel_tol  = 0.05; % m/s

quad_state = x0;
%pl_dim_num = 13; % rigid body
pl_dim_num = 6; % point mass
quad_dim_num = 13;

global cable_is_slack;
cable_is_slack = ~istaut(x(1:3), x(7:9),pl_params.cable_length);

%% ************************* RUN SIMULATION *************************
fprintf('Simulation Running....\n')
for iter = 1:max_iter
    timeint = time:tstep:time+cstep;
    tic;

    % Inelastic collision
    pl_pos = x(1:3);
    pl_vel = x(4:6);
    robot_pos = x(7:9);
    robot_vel = x(10:12);
    cable_norm_vel = (pl_pos - robot_pos)'*(pl_vel - robot_vel);
    if cable_norm_vel > 1e-6 && ~cable_is_slack
        [x(4:6),x(10:12)] = ptmass_inelastic_cable_collision(x(1:6), x(7:12),pl_params.mass,quad_params.mass);
    end
        
    % Simulate Dynamics 
    if cable_is_slack
        % The integration stops when the distance between robot and payload
        % equals to the cable length
        option = odeset('Events',@(t,x)slackToTaut(t,x,pl_params.cable_length));
        [tsave, xsave, fsave] = ode45(@(t,s)dynamicshandle(t,s,pl_params), timeint, x, option);
    else
        option = odeset('Events',@(t,x)tautToSlack(t,x,pl_params.cable_length));
        [tsave, xsave, fsave] = ode45(@(t,s)dynamicshandle(t,s,pl_params), timeint, x, option);
    end
    
    x = xsave(end, :)';
    cable_is_slack = ~istaut(xsave(end,1:3)', xsave(end,7:9)',pl_params.cable_length);
    
    % Save to traj
    xtraj{1} = [xtraj{1},xsave(1:end-1,:)'];
    ttraj{1} = [ttraj{1},tsave(1:end-1)'];
    for i = 1:length(tsave)-1
        desired_state = trajhandle(tsave(i), []);
        xtrajdes{1} = [xtrajdes{1},[desired_state.pos_des;desired_state.vel_des]];
    end
    
    % Update payload plot
    desired_state = trajhandle(time + cstep, []);
    payload_state = x(1:pl_dim_num);
    quad_state{1} = x(pl_dim_num+1:end);
    
    % Update payload path
    path_msg.points(iter).x = payload_state(1);
    path_msg.points(iter).y = payload_state(2);
    path_msg.points(iter).z = payload_state(3);
    path_time = rostime('now');
    path_msg.header.stamp.sec = uint32(path_time.Sec);
    path_msg.header.stamp.nsec = uint32(path_time.Nsec);
    send(path_pub, path_msg);
    
    % Update payload desired path
    des_path_msg.points(iter).x = desired_state.pos_des(1);
    des_path_msg.points(iter).y = desired_state.pos_des(2);
    des_path_msg.points(iter).z = desired_state.pos_des(3);
    des_path_msg.header.stamp.sec = uint32(path_time.Sec);
    des_path_msg.header.stamp.nsec = uint32(path_time.Nsec);
    send(des_path_pub, des_path_msg);
    
    % Update quadrotor visualization
    system_marker.markers(qn) = update_marker_msg(quadrotor_marker_msg{qn},quad_state{qn}(1:3),RotToQuat(QuatToRot(quad_state{qn}(7:10))'),qn);
    
    % Update cable visualization
    cable_point_list =  [payload_state(1:3),quad_state{1}(1:3)];
    system_marker.markers(2) = update_line_list_msg(cable_marker_msg,cable_point_list,2);
    
    % Update payload visualization
    system_marker.markers(3) = update_marker_msg(payload_marker_msg,payload_state(1:3),[1;0;0;0],0);
    
    % Publish the marker message
    send(system_pub, system_marker);  
    
    % Update simulation time
    time = time + tsave(end) - tsave(1); 
    t = toc
    
    % Pause to make real-time
    if (t < cstep)
        %fprintf('t is smaller than cstep\n')
        pause(cstep - t);
    end
    
    % Check termination criteria
    terminate_cond = terminate_check(x, time, loadstop, pos_tol, vel_tol, time_tol);
    if terminate_cond
       break
    end
    
end

fprintf('Simulation Finished....\n')

end
