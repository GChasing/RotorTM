function [xtraj, xtrajdes, ttraj, terminate_cond] = rigid_links_test_trajectory(start, loadstart, loadstop, vis,trajhandle,pl_params,quad_params)
% TEST_TRAJECTORY simulates the robot from START to STOP following a PATH
% that's been planned for MAP.
% start - a 3d vector or a cell contains multiple 3d vectors
% stop  - a 3d vector or a cell contains multiple 3d vectors
% map   - map generated by your load_map
% path  - n x 3 matrix path planned by your dijkstra algorithm
% vis   - true for displaying visualization



% % Quadrotor model
% params = snapdragonflight();
% 
% % Payload model
% pl_params = robot_team_setup(trianglepayload(),params,"Rigid Link");
nquad = pl_params.nquad;

% ros initialization
worldframe = 'simulator';
payloadframe = 'payload';% tftree = rostf;

% cable_pub = rospublisher("/cable/marker","visualization_msgs/Marker","DataFormat","struct");
% cable_marker_scale = 0.01*ones(3);
% cable_marker_color = [1.0,1.0,0.0,0.0];
% cable_marker_msg = init_marker_msg(cable_pub,5,0,worldframe,cable_marker_scale,cable_marker_color);

for i = 1:nquad
    robot_marker_pub{i} = rospublisher("/quadrotor"+num2str(i)+"/marker","visualization_msgs/Marker","DataFormat","struct");
    quadrotor_marker_scale = 0.5*ones(3);
    quadrotor_marker_color = [1.0,0.0,0.0,1.0];
    quadrotor_mesh = quad_params.mesh_path;
    quadrotor_marker_msg{i} = init_marker_msg(robot_marker_pub{i} ,10,0,worldframe,quadrotor_marker_scale,quadrotor_marker_color,quadrotor_mesh);
end

pl_odom_pub = rospublisher("/payload/marker","visualization_msgs/Marker","DataFormat","struct");
payload_marker_scale = ones(3);
payload_marker_color = [1.0,0.745,0.812,0.941]

system_pub = rospublisher("/system/marker","visualization_msgs/MarkerArray","DataFormat","struct");
system_marker = rosmessage(system_pub);

path_pub = rospublisher("/payload/path","visualization_msgs/Marker","DataFormat","struct");
path_scale = 0.01*ones(3);
path_color = [1.0,1.0,0.0,0.0];
path_msg = init_marker_msg(path_pub,4,0,worldframe,path_scale,path_color);

des_path_pub = rospublisher("/payload/des_path","visualization_msgs/Marker","DataFormat","struct");
des_path_scale = 0.01*ones(3);
des_path_color = [1.0,0.341,0.0235,0.549];
des_path_msg = init_marker_msg(des_path_pub,4,0,worldframe,des_path_scale,des_path_color);

controlhandle = @rigid_links_cooperative_payload_controller;
dynamicshandle = @(t,s) rigid_links_cooperative_rigidbody_pl_EOM(t, s, nquad, controlhandle, trajhandle, quad_params, pl_params);
payload_mesh = pl_params.mesh_path;%'package://RotorTM/mesh/triangular_payload.STL';
payload_marker_msg = init_marker_msg(pl_odom_pub,10,0,worldframe,payload_marker_scale,payload_marker_color,payload_mesh);

% Make cell
if ~iscell(start), start = {start}; end

%% **************************** FIGURES *****************************
% Environment figure
if nargin < 5
    vis = true;
end

fprintf('Initializing figures...\n')
if vis
    h_fig = figure('Name', 'Environment');
else
    h_fig = figure('Name', 'Environment', 'Visible', 'Off');
end

h_3d = gca;
drawnow;
xlabel('x [m]'); ylabel('y [m]'); zlabel('z [m]')
quadcolors = lines(nquad);
set(gcf,'Renderer','OpenGL')

%% *********************** INITIAL CONDITIONS ***********************
fprintf('Setting initial conditions...\n')
% Maximum time that the quadrotor is allowed to fly
time_tol = 60;          % maximum simulation time
starttime = 0;          % start of simulation in seconds
tstep     = 0.01;       % this determines the time step at which the solution is given
cstep     = 0.05;       % image capture time interval
nstep     = cstep/tstep;
time      = starttime;  % current time
max_iter  = time_tol / cstep;      % max iteration

pl0 = [loadstart(1:3);0;0;0;loadstart(4:7);0;0;0];
x = pl0;
% Here we just return the traj hist of the structure
for qn = 1:1
    xtrajdes{qn} = [];
    xtraj{qn} = [];
    ttraj{qn} = [];
end

% Maximum position error of the quadrotor at goal
pos_tol  = 0.001; % m
% Maximum speed of the quadrotor at goal
vel_tol  = 0.001; % m/s

% state vector x (13 + 7*nquad + 6*nquad) x 1:
% x     - [xL, yL, zL, xLd, yLd, zLd,
%          [xL, yL, zL, xLd, yLd, zLd, qw, qx, qy, qz, pQuad, qQuad, rQuad]_i, i = 1,...,nquad
%pl_dim_num = 13; % rigid body
pl_dim_num = 6; % point mass
quad_dim_num = 13;

%% ************************* RUN SIMULATION *************************
fprintf('Simulation Running....\n')
for iter = 1:max_iter
    
    timeint = time:tstep:time+cstep;
    tic;
    
    % State Integration
    [tsave, xsave, fsave] = ode45(@(t,s)dynamicshandle(t,s), timeint, x);
    x = xsave(end, :)'; 

    Rot = QuatToRot(x(7:10))';
    load_pos = x(1:3) + Rot*pl_params.rho_load;
    robot_pos = x(1:3) + Rot*pl_params.rho_robot;
    
    % Update quadrotor visualization
    for qn=1:nquad
        system_marker.Markers(qn) = update_marker_msg(quadrotor_marker_msg{qn},robot_pos(:,qn),RotToQuat(Rot),qn);
    end
    
    % Update payload visualization msg
    system_marker.Markers(nquad+1) = update_marker_msg(payload_marker_msg,load_pos,RotToQuat(Rot));
    
    send(system_pub, system_marker);
    
    
    % Save to traj
    for qn = 1:1
            xtraj{qn} = [xtraj{qn},xsave(1:end-1,13*qn-12:13*qn)'];
            ttraj{qn} = [ttraj{qn},tsave(1:end-1)'];
            for i = 1:length(tsave)-1
                desired_state = trajhandle(tsave(i), []);
                xtrajdes{qn} = [xtrajdes{qn},[desired_state.pos_des;desired_state.vel_des;desired_state.quat_des';desired_state.omega_des']];
            end
    end
    
    path_msg.Points(iter).X = x(1);
    path_msg.Points(iter).Y = x(2);
    path_msg.Points(iter).Z = x(3);
    path_time = rostime('now');
    path_msg.Header.Stamp.Sec = uint32(path_time.Sec);
    path_msg.Header.Stamp.Nsec = uint32(path_time.Nsec);
    send(path_pub, path_msg);
    des_path_msg.Points(iter).X = desired_state.pos_des(1);
    des_path_msg.Points(iter).Y = desired_state.pos_des(2);
    des_path_msg.Points(iter).Z = desired_state.pos_des(3);
    des_path_msg.Header.Stamp.Sec = uint32(path_time.Sec);
    des_path_msg.Header.Stamp.Nsec = uint32(path_time.Nsec);
    send(des_path_pub, des_path_msg);
    
    % Update simulation time
    time = time + cstep; 
    t = toc;
    
    % Pause to make real-time
    if (t < cstep)
        %fprintf('t is smaller than cstep\n')
        pause(cstep - t);
    end
    
    % Check termination criteria
    terminate_cond = terminate_check(x, time, loadstop, pos_tol, vel_tol, time_tol);
    if terminate_cond
        break
    end
    
end

fprintf('Simulation Finished....\n')

end
